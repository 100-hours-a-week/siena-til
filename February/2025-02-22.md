## 📅 날짜: 2025-02-22~23


### 💬 학습 목표

- 학습 목표 1 : 스프링 핵심 원리 - 기본편 섹션2
- 학습 목표 2 : 와이어프레임 수정


### 🍃 스프링 핵심 원리 - 섹션2. 객체지향설계와 스프링

#### | 스프링이란?

자바 언어 기반의 프레임워크

즉 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크!

**스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크**


#### | 좋은 객체 지향 프로그래밍이란?

객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러개의 독립된 단위, 즉 객체들의 모임으로 파악하고자 하는 것이다. 각각의 객체는 메시지를 주고받고 데이터를 처리할 수 있다.

객체 지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다.

1. 객체 지향 특징

- 추상화
- 캡슐화
- 상속
- **다형성 (Polymorphism)**
    
    역할과 구현을 분리한다.. 와우..
    ⇒ 대체 가능하다, 확장이 가능하다 ⇒ 유연하다!!!!
    
    핵심은 **클라이언트!**
    
    - 클라이언트는 대상의 역할(인터페이스)만 알면 된다.
    - 클라이언트는 구현 대상의 내부 구조를 몰라도된다.
    - 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다.
    - 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다.

    ⇒ 자바 언어가 이러한 다형성을 활용한다.

        - 역할 = 인터페이스
        - 구현 = 인터페이스를 구현한 클래스, 구현 객체

        객체를 설계할 때 역할과 구현을 명확히 분리하자.

        객체를 설계할 때 역할(인터페이스)를 먼저 부여하고, 그 역할을 수행하는 구현 객체를 만들자.

2. **스프링과 객체 지향**

- 스프링은 **다형성**을 극대화해서 이용할 수 있게 도와준다.
- 스프링에서 이야기하는 **제어의 역전(IoC)**, **의존관계 주입(DI)**은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다.

#### | 좋은 객체 지향 설계의 5가지 원칙(SOLID)

**SOLID**

- SRP (Single Responsibility Principle, 단일 책임 원칙)
    - 한 클래스는 **하나의 책임**만 가져야 한다.
        
        이때 **하나의 책임**이라는 것이 모호할 수 있음 (클 수도 있고 작을 수도 있고 문맥과 상황에 따라다름) 
        
        중요한 기준은 **변경**이다.
        
        **변경이 있을 때 파급효과가 적으면 단일 책임 원칙을 잘 따른 것!**
        
    - ex) UI 변경, 객체의 생성과 사용을 분리
- **OCP (Open/Closed Principle, 개방/폐쇄 원칙)**
    - 소프트웨어 요소는 **확장에는 열려 있으나 변경에는 닫혀 있어야 한다.**
        
        ⇒ 다형성을 활용해보자!
        
        ⇒ **인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현**
        
    
    즉, 새로운 코드를 작성해서 확장하지만 기존의 클라이언트 코드는 변경할 필요가 없다!
    
    그런데;;
    
    ```java
    public class MemberService {
    	
    	// private MemberRepository memberRepository = new MemoryMemberRepository();
    	private MemberRepository memberRepository = new JdbcMemberRepository();
    }
    ```
    
    - 기존코드: 역할 `MemberRepository` - 구현 `MemoryMemberRepository`
    - 변경 코드: 역할 `MemberRepository` - 구현 `JdbcMemberRepository`
    
    구현 객체를 변경하려면 클라이언트인 `MemberService` 를 변경해야한다!!!!!?!!?
    분명 다형성을 사용했지만 OCP 원칙을 지킬 수 없음… <<<????
    
    ⇒ 객체를 생성하고 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다!!
    
    ⇒ 그 설정자가 스프링이다!!!!!!!!!!!!!!!!!!1 (소위 스프링컨테이너가 해준대..
    
- LSP (Liskov Substitution Principle, 리스코프 치환 원칙)
    - 프로그램 객체는 프로그램의 정확성을 깨뜨리지 않으면서,
    하위 타입의 인스턴스로 바꿀 수 있어야한다.
    - 예를 들어 자동차 인터페이스(역할)가 있다. 액셀 기능을 구현하려고 한다. 
    이때 액셀기능은 엑셀을 밟았을 때 차를 앞으로 전진시키는 기능이다. 
    액셀을 밟았을 때 차를 후진시키도록 만들수는 있겠지만(컴파일은 성공하겠지만)
    그렇게 만든다면 프로그램의 정확성이 깨지는 것! ⇒ LSP 위반!
        
        즉 기능 구현은 인터페이스 규약을 무조건 보장해야한다!!
        
- ISP (Interface Segregation Principle, 인터페이스 분리 원칙)
    - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
    - 예를 들어 자동차 인터페이스 → 운전 인터페이스, 정비 인터페이스로 분리
    사용자 클라이언트 → 운전자 클라이언트, 정비사 클라이언트로 분리
        
        ⇒ 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않는다.
        
    - 인터페이스가 명확해지고 대체 가능성이 높아진다!
- DIP (Dependency Inversion Principle 의존관계 역전 원칙)
    - 프로그래머는 **추상화에 의존**해야지, 구체화에 의존하면 안된다.
        
        ⇒ 구현 클래스에 의존하지 말고, **인터페이스에 의존**해야한다.
        
    - 역할에 의존해야지 구현에 의존하면 안된다!!!!!1
    
    OCP에서 언급된 `MemberService`는 인터페이스에 의존하지만 구현 클래스도 동시에 의존한다. (`MemberService` 클라이언트가 구현 클래스를 직접 선택하기 때문)
    
    ⇒ DIP 위반! ⇒ 구체화에 의존했다 !!!!!1
    

- 정리

    - 객체 지향의 핵심은 **다형성**
    - 다형성만으로는 쉽게 부품 갈아끼우듯이 개발할 수 없다.
    - 다형성만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
    - 다형성만으로는 OCP와 DIP를 지킬 수 없다.

    ⇒ 뭔가 더 필요하다!!!!!!!!!! 근데 그 뭔가가 스프링일 수 있다!

#### | 객체 지향 설계와 스프링

**스프링은 아래 기술을 통해 다형성 + OCP, DIP를 가능하게 지원한다!**

- DI(Dependency Injection): 의존 관계, 의존성 주입
- DI 컨테이너 제공

⇒ 클라이언트 코드의 변경 없이 기능 확장이 가능하게 한다.

### 🧑‍🧒‍🧒 팀 스터디 - 코딩테스트
#### | 매일 한 문제 이상 풀기!

1. (오늘) 내가 푼 문제

- 12주차
    - 백준 2693, 5176, 10773, 3040, 3058

### 🔥 도전 과제 달성 확인, 내일의 도전과제 설정
- (지난) 도전 과제 1: 스프링 강의 섹션 2까지 듣기 ✅

- (내일) 도전 과제 1: ERD 작성 마무리하기

<br/>

### 💭 오늘의 회고
- 성공적인 점: 주말에 스프링강의 들었다! <br/>
- 개선해야할 점: 많이는 못들었다..🥲 <br/>


<br/>

### 📁 참고 자료 및 링크
