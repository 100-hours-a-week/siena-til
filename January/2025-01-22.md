
## 📅 날짜: 2025-01-22


### 💬 학습 목표

- 학습 목표 1 : 1/17 쿠버네티스 강의 내용 정리하기
- 학습 목표 2 : 딥다이브


### 🤿 딥다이브 - 쿠버네티스
#### | 쿠버네티스에서 데이터 영속성을 보장하는 방법

[전체내용](https://www.notion.so/adapterz/182f192a595a4b8599fff80d22bc55f9?pvs=4)

0. Volume

    - What is Volume in K8s?
        - K8s 볼륨은 Pod내의 컨테이너에 접근할 수 있는 데이터를 저장하는 디렉토리입니다.
        - K8s 볼륨은 임시 데이터 스토리지와 영구 데이터 스토리지를 포함합니다.

    - What is different volume in k8s, Docker

        |  | **Kubernetes 볼륨** | **Docker 볼륨** |
        | --- | --- | --- |
        | **단위** | Pod | 컨테이너 |
        | **수명** | Pod (또는 PersistentVolume으로 영구화) | 컨테이너와 독립적 |
        | **통합 스토리지** | 다양한 스토리지 통합 지원 | 호스트 디스크 기반 |
        | **복잡성** | 설정 및 관리 복잡 | 간단한 설정 |
        | **주요 사용 사례** | 클러스터 환경에서 스토리지 공유 및 관리 | 개별 컨테이너 데이터 지속성 유지 |

        둘의 주요 차이는 단일 컨테이너 관리(Docker)와 다중 컨테이너와 클러스터 관리(K8s)의 관점에서 나타납니다. K8s 볼륨은 도커에 비해 더 광범위하고 유연한 스토리지 관리 옵션을 제공합니다.

1. PV & PVC

    - PersistentVolume
        - PV는 데이터 저장소를 추상화시킨 리소스입니다.
        - 쿠버네티스 관리자가 **데이터 저장소**를 사용하기 위해 미리 마련한 저장 리소스을 나타냅니다.
            **데이터 저장소** ex) hostPath, NFS, AWS EBS
    

    - PersistentVolumeClaim
        - PVC는 저장소 사용자가 PV를 요청하는 리소스입니다.
        - 관리자가 PV를 통해 데이터 저장소를 준비하면 사용자가 PVC 요청을 통해 해당 리소스를 선점합니다.

2. 정적 프로비저닝 vs 동적 프로비저닝

    - what is PV provisioning in K8s?

        K8s에서 **PV의 프로비저닝**은 **스토리지 자원을 할당하는 방식**으로 정적(static) 프로비저닝과 동적(dynamic) 프로비저닝 두가지가 있습니다.

    - **정적 프로비저닝**

        **정적 프로비저닝**은 클러스터 관리자가 **미리 스토리지를 준비하고, PV를 생성**하여 Kubernetes에서 사용할 수 있도록 등록하는 방식입니다.

        <img width="670" alt="Image" src="https://github.com/user-attachments/assets/bfb85aa8-eb55-43f7-8b17-71b2646b8267" />

    - **동적 프로비저닝**

        **동적 프로비저닝**은 **K8s가 사용자의 PVC 요청에 따라 스토리지를 자동으로 생성**하는 방식입니다.

        <img width="670" alt="Image" src="https://github.com/user-attachments/assets/e8f352c1-0231-42fa-82e4-211350c6bc20" />

        그림에 나온 순서 전에! 관리자가 StorageClass를 생성하고 프로비저닝 규칙을 정의해야합니다.

    - 정적 프로비저닝과 동적 프로비저닝의 가장 큰 차이점은?
        1. StorageClass 의 역할
        2. 자동화

3. 결론

    **K8s에서는 persistentVolume을 사용하여 데이터의 영속성을 보장합니다.**

#### | 🕸️ K8s와 친해지기 - 빅토리아

0. 들어가기 전 **컨테이너 런타임 vs 컨테이너 오케스트레이션** <br/>

컨테이너 런타임: 개별 컨테이너를 생성, 실행 및 관리하는 소프트웨어 <br/>
컨테이너 오케스트레이션: 컨테이너화된 애플리케이션의 프로비저닝, 배포, 스케일링 및 라이프 사이클 관리를 자동화하는 프로세스

1.K8s란?

K8s란 **컨테이너화된 소프트웨어 애플리케이션과 서비스를 배포, 관리 및 확장하는 작업을 자동화하는 오픈소스 컨테이너 오케스트레이션 플랫폼**입니다.

1.1 등장 배경

    베어메탈 환경 - 가상화 기술 도입 - 컨테이너 기술의 도입

1.2 컨테이너 오케스트레이션 플랫폼에서 K8s의 경쟁력

    - 확장성과 유연성
    - 풍부한 기능과 생태계
    - 멀티 클라우드 및 하이브리드 클라우드 지원
    - 활발한 커뮤니티와 오픈소스 생태계
    - Google Name Value, 신뢰성과 강력한 지원

2. K8s 구성요소

2.1 Control Plane: 클러스터의 상태를 관리하고, 작업을 스케줄링합니다.

    - etcd
    - API Server
    - Controller Manager
    - Scheduler

2.2 Worker Node: 실제 애플리케이션이 실행되는 서버입니다.

    - kubelet
    - Kube-Proxy
    

#### | 😒 서비스(Service) 이해하기 - 리로이
주제: 서비스를 통해 파드에 트래픽을 라우팅하는 방법

1. 서비스?
파드들이 네트워크 서비스를 받을 수 있도록 서빙하는 역할로, **네트워크 접속을 추상화한 리소스**

    ❓ 왜 파드IP를 직접 사용하지 않고 Service를 통해서 할까?
    - 파드의 IP변동성
        파드는 생성하고 삭제가 자주 일어나기때문에 IP 변동이 자주 발생함 때문에 고정적인 IP를 가진 Service가 효율적임
    - 로드 밸런싱 제공
    - 내부 DNS 지원
        클러스터 내부 DNS 를 통해 이름 기반 접근이 가능

2. 서비스의 종류

    - ClusterIP: 쿠버네티스 내부로만 접근할 수 있는 기본 Service 타입 (내부통신만 가능!)
    - NodePort: 쿠버네티스 노드의 특정포트(30000~32767)를 열어서 클러스터 외부(LAN,PC)에서도 `노드IP:NodePort`로 직접 접근할 수 있게 하는 타입
    - LoadBalancer: Pod간의 로드밸런싱을 자동으로 수행하여 트래픽을 분산합니다.
    - ExternalName: 쿠버네티스 외부에 있는 서비스를 내부 DNS로 매핑할 때 사용


#### | ♻️ 쿠버네티스에서 제공하는 롤링 업데이트와 다양한 배포전략 - 테디

0. 무중단 배포 : 서비스 중단 없이 새로운 버전의 소프트웨어를 배포하는 기술

1. 롤링 배포 : 정해진 비율만큼의 파드만 점진적으로 배포 <br/>

    - 방식1: 인스턴스를 하나 추가하고 새로운 버전을 실행한다.
        로드밸런서에 이 인스턴스를 연결 후 기존 구버전 어플리케이션이 실행되는 인스턴스를 하나 줄인다.
        => 서버 개수를 유연하게 조절할 수 있는 클라우드 기반 서비스 운영에서 적합

    - 방식2: V1이 실행되고 있는 서버 하나를 로드밸런스에서 떼어내 해당 서버에 트래픽이 도달하지 않게 한다.
        해당 서버의 어플리케이션을 V2로 교체하고 이 과정을 반복해서 모든 서버를 새로운 버전으로 교체한다.
        => 클라우드 환경이 아닌 물리적인 서버로 서비스를 운영하는 상황에서 사용 가능

    - 장점

        - 인스턴스가 차례로 배포되어 손쉽게 롤백 가능
        - 많은 서버 자원을 확보하지 않아도 무중단 배포 가능
        - 관리가 간편하다.
    
    - 단점

        - 새버전을 배포할 때 인스턴스의 수가 감소하기 때문에 사용중인 인스턴스에 트래픽이 몰릴 수 있다.
        - 배포가 진행될 때 구버전과 신버전이 공존하여 호환성 문제가 발생할 수 있다.

2. 블루-그린 배포: 구버전과 신버전의 인스턴스를 구성한 후 로드밸런서를 통해 모든 트래픽을 한번에 신버전으로 전환하는 방식

    - 현재 운영중인 서비스 환경: 블루, 신버전: 그린
    
    - 장점

        - 구버전과 동일한 운영환경에 신버전의 인스턴스들을 올리기 때문에 실제 서비스 배포 환경에서 신버전을 미리 테스트 해볼 수 있다.
        - 구버전의 인스턴스가 그대로 남아있어서 롤백이 쉽다.
        - 구버전을 다음 배포에 재사용할 수 있다?
    
    - 단점

        - 시스템 자원이 두배로 필요합니다.

#### | 🐥 확장성(Autoscaling)과 리소스

주제: HPA(Horizontal Pod Autoscaler), VPA(Vertical Pod Autoscaler)를 통한 자동 확장

우렁선정 ❓왜 쿠버네티스를 쓰는가? <br/>
❗️ 확장성과 리소스관리를 할 수 있기때문에!

1. HPA(Horizontal Pod Autoscaler)
CPU 사용률 등 메트릭 기반 스케일 아웃/인 기능

오토스케일링을 수행하기 위해서는 CPU나 메모리 사용량 정보를 제공 받아야한다. <br/>
이를 위해 metrics-server 을 설치! <br/>

`hpa.yaml` 의 일부 <br/>

```yaml
targetCPUUtilizationPercentage: 50 // CPU활용률이 50% 이상인 경우
maxReplicas: 10 // Pod를 최대 10개 까지 늘립니다.
minReplicas: 1 // Pod를 최소 1개개까지 줄입니다.
```
위와 같이 설정해서 설정값에 따라 레플리카수를 조절한다.

2. VPA(Vertical Pod Autoscaler)
컨테이너에 할당하는 CPU/Memory 리소스의 할당을 자동으로 스케일

HPA가 파드를 스케일 아웃한다면 VPA는 파드를 스케일업한다!

3. 파드 리소스 요청(Request)과 제한(Limit)을 설정하는 이유와, 이를 통해 얻을 수 있는 이점
클러스터내 리소스를 효율적으로 관리하기 위해 리소스 요청과 제한을 설정한다.

- 이점 

    - 스케줄링 최적화
    - 리소스 보장
    - 리소스 과다 사용 방지
    - 시스템 안정성 확보

### 🧑‍🧒‍🧒 팀 스터디 - 코딩테스트
#### | 매일 한 문제 이상 풀기!

1. (오늘) 내가 푼 문제

- 8주차
    - 백준 5065 10102

2. 백준 그룹 만들었당

<img width="200" alt="Image" src="https://github.com/user-attachments/assets/347f15de-512f-48b4-a616-82f253a220f9" />

트리니티 화이팅


### 🔥 도전 과제 달성 확인, 내일의 도전과제 설정
- (지난) 도전 과제 1: 딥다이브 열심히 참여하기 ✅

- (내일) 도전 과제 1: 수업 열심히 듣기!

<br/>

### 💭 오늘의 회고 (총 공부 시간 8:02:38)
- 성공적인 점: 복습했던 내용이 딥다이브 주제로 나와서 자료를 잘 준비할 수 있었다! <br/>
- 개선해야할 점: 발표연습할 시간이 부족해서 발표할때 맨날 떤다ㅠㅠ 준비한 말이 있는데 맨날 프리스타일함.. 고치기!!!! <br/>

<br/>

### 📁 참고 자료 및 링크
